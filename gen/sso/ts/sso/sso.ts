// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "sso/sso.proto" (package "auth", syntax proto3)
// tslint:disable
import { Empty } from "../google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message auth.DiscoveryResponse
 */
export interface DiscoveryResponse {
    /**
     * @generated from protobuf field: string issuer = 1;
     */
    issuer: string;
    /**
     * @generated from protobuf field: string authorization_endpoint = 2;
     */
    authorizationEndpoint: string;
    /**
     * @generated from protobuf field: string token_endpoint = 3;
     */
    tokenEndpoint: string;
    /**
     * @generated from protobuf field: string jwks_uri = 4;
     */
    jwksUri: string;
    /**
     * @generated from protobuf field: string userinfo_endpoint = 5;
     */
    userinfoEndpoint: string;
    /**
     * @generated from protobuf field: repeated string response_types_supported = 6;
     */
    responseTypesSupported: string[];
    /**
     * @generated from protobuf field: repeated string subject_types_supported = 7;
     */
    subjectTypesSupported: string[];
    /**
     * @generated from protobuf field: repeated string id_token_signing_alg_values_supported = 8;
     */
    idTokenSigningAlgValuesSupported: string[];
    /**
     * @generated from protobuf field: repeated string scopes_supported = 9;
     */
    scopesSupported: string[];
    /**
     * @generated from protobuf field: repeated string claims_supported = 10;
     */
    claimsSupported: string[];
}
/**
 * @generated from protobuf message auth.AuthorizationRequest
 */
export interface AuthorizationRequest {
    /**
     * @generated from protobuf field: string client_id = 1;
     */
    clientId: string;
    /**
     * @generated from protobuf field: string redirect_uri = 2;
     */
    redirectUri: string;
    /**
     * @generated from protobuf field: string response_type = 3;
     */
    responseType: string;
    /**
     * @generated from protobuf field: string scope = 4;
     */
    scope: string;
    /**
     * @generated from protobuf field: string state = 5;
     */
    state: string;
    /**
     * @generated from protobuf field: string code_challenge = 6;
     */
    codeChallenge: string;
    /**
     * @generated from protobuf field: string code_challenge_method = 7;
     */
    codeChallengeMethod: string;
    /**
     * @generated from protobuf field: string nonce = 8;
     */
    nonce: string;
}
/**
 * @generated from protobuf message auth.AuthorizationResponse
 */
export interface AuthorizationResponse {
    /**
     * @generated from protobuf field: string redirect_uri = 1;
     */
    redirectUri: string;
    /**
     * @generated from protobuf field: string code = 2;
     */
    code: string;
    /**
     * @generated from protobuf field: string state = 3;
     */
    state: string;
}
/**
 * @generated from protobuf message auth.TokenRequest
 */
export interface TokenRequest {
    /**
     * @generated from protobuf field: string grant_type = 1;
     */
    grantType: string;
    /**
     * @generated from protobuf field: string code = 2;
     */
    code: string;
    /**
     * @generated from protobuf field: string redirect_uri = 3;
     */
    redirectUri: string;
    /**
     * @generated from protobuf field: string code_verifier = 4;
     */
    codeVerifier: string;
    /**
     * @generated from protobuf field: string client_id = 5;
     */
    clientId: string;
    /**
     * @generated from protobuf field: string client_secret = 6;
     */
    clientSecret: string;
}
/**
 * @generated from protobuf message auth.TokenResponse
 */
export interface TokenResponse {
    /**
     * @generated from protobuf field: string access_token = 1;
     */
    accessToken: string;
    /**
     * @generated from protobuf field: string token_type = 2;
     */
    tokenType: string;
    /**
     * @generated from protobuf field: int64 expires_in = 3;
     */
    expiresIn: bigint;
    /**
     * @generated from protobuf field: string id_token = 4;
     */
    idToken: string;
    /**
     * @generated from protobuf field: string refresh_token = 5;
     */
    refreshToken: string;
}
/**
 * @generated from protobuf message auth.UserInfoResponse
 */
export interface UserInfoResponse {
    /**
     * @generated from protobuf field: string sub = 1;
     */
    sub: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string email = 3;
     */
    email: string;
    /**
     * @generated from protobuf field: bool email_verified = 4;
     */
    emailVerified: boolean;
}
/**
 * @generated from protobuf message auth.JWKSResponse
 */
export interface JWKSResponse {
    /**
     * @generated from protobuf field: repeated auth.JWKSResponse.JWK keys = 1;
     */
    keys: JWKSResponse_JWK[];
}
/**
 * @generated from protobuf message auth.JWKSResponse.JWK
 */
export interface JWKSResponse_JWK {
    /**
     * @generated from protobuf field: string kty = 1;
     */
    kty: string;
    /**
     * @generated from protobuf field: string kid = 2;
     */
    kid: string;
    /**
     * @generated from protobuf field: string use = 3;
     */
    use: string;
    /**
     * @generated from protobuf field: string alg = 4;
     */
    alg: string;
    /**
     * @generated from protobuf field: string n = 5;
     */
    n: string;
    /**
     * @generated from protobuf field: string e = 6;
     */
    e: string;
}
/**
 * Original Messages
 *
 * @generated from protobuf message auth.RegisterRequest
 */
export interface RegisterRequest {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
}
/**
 * @generated from protobuf message auth.RegisterResponse
 */
export interface RegisterResponse {
    /**
     * @generated from protobuf field: int64 user_id = 1;
     */
    userId: bigint;
}
/**
 * @generated from protobuf message auth.LoginRequest
 */
export interface LoginRequest {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
    /**
     * @generated from protobuf field: int32 app_id = 3;
     */
    appId: number;
}
/**
 * @generated from protobuf message auth.LoginResponse
 */
export interface LoginResponse {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string;
}
/**
 * @generated from protobuf message auth.IsAdminRequest
 */
export interface IsAdminRequest {
    /**
     * @generated from protobuf field: int64 user_id = 1;
     */
    userId: bigint;
}
/**
 * @generated from protobuf message auth.IsAdminResponse
 */
export interface IsAdminResponse {
    /**
     * @generated from protobuf field: bool is_admin = 1;
     */
    isAdmin: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class DiscoveryResponse$Type extends MessageType<DiscoveryResponse> {
    constructor() {
        super("auth.DiscoveryResponse", [
            { no: 1, name: "issuer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "authorization_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "token_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "jwks_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "userinfo_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "response_types_supported", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "subject_types_supported", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "id_token_signing_alg_values_supported", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "scopes_supported", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "claims_supported", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DiscoveryResponse>): DiscoveryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.issuer = "";
        message.authorizationEndpoint = "";
        message.tokenEndpoint = "";
        message.jwksUri = "";
        message.userinfoEndpoint = "";
        message.responseTypesSupported = [];
        message.subjectTypesSupported = [];
        message.idTokenSigningAlgValuesSupported = [];
        message.scopesSupported = [];
        message.claimsSupported = [];
        if (value !== undefined)
            reflectionMergePartial<DiscoveryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiscoveryResponse): DiscoveryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string issuer */ 1:
                    message.issuer = reader.string();
                    break;
                case /* string authorization_endpoint */ 2:
                    message.authorizationEndpoint = reader.string();
                    break;
                case /* string token_endpoint */ 3:
                    message.tokenEndpoint = reader.string();
                    break;
                case /* string jwks_uri */ 4:
                    message.jwksUri = reader.string();
                    break;
                case /* string userinfo_endpoint */ 5:
                    message.userinfoEndpoint = reader.string();
                    break;
                case /* repeated string response_types_supported */ 6:
                    message.responseTypesSupported.push(reader.string());
                    break;
                case /* repeated string subject_types_supported */ 7:
                    message.subjectTypesSupported.push(reader.string());
                    break;
                case /* repeated string id_token_signing_alg_values_supported */ 8:
                    message.idTokenSigningAlgValuesSupported.push(reader.string());
                    break;
                case /* repeated string scopes_supported */ 9:
                    message.scopesSupported.push(reader.string());
                    break;
                case /* repeated string claims_supported */ 10:
                    message.claimsSupported.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DiscoveryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string issuer = 1; */
        if (message.issuer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.issuer);
        /* string authorization_endpoint = 2; */
        if (message.authorizationEndpoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.authorizationEndpoint);
        /* string token_endpoint = 3; */
        if (message.tokenEndpoint !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.tokenEndpoint);
        /* string jwks_uri = 4; */
        if (message.jwksUri !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.jwksUri);
        /* string userinfo_endpoint = 5; */
        if (message.userinfoEndpoint !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.userinfoEndpoint);
        /* repeated string response_types_supported = 6; */
        for (let i = 0; i < message.responseTypesSupported.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.responseTypesSupported[i]);
        /* repeated string subject_types_supported = 7; */
        for (let i = 0; i < message.subjectTypesSupported.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.subjectTypesSupported[i]);
        /* repeated string id_token_signing_alg_values_supported = 8; */
        for (let i = 0; i < message.idTokenSigningAlgValuesSupported.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.idTokenSigningAlgValuesSupported[i]);
        /* repeated string scopes_supported = 9; */
        for (let i = 0; i < message.scopesSupported.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.scopesSupported[i]);
        /* repeated string claims_supported = 10; */
        for (let i = 0; i < message.claimsSupported.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.claimsSupported[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.DiscoveryResponse
 */
export const DiscoveryResponse = new DiscoveryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizationRequest$Type extends MessageType<AuthorizationRequest> {
    constructor() {
        super("auth.AuthorizationRequest", [
            { no: 1, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "redirect_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "response_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "scope", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "code_challenge", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "code_challenge_method", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "nonce", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuthorizationRequest>): AuthorizationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = "";
        message.redirectUri = "";
        message.responseType = "";
        message.scope = "";
        message.state = "";
        message.codeChallenge = "";
        message.codeChallengeMethod = "";
        message.nonce = "";
        if (value !== undefined)
            reflectionMergePartial<AuthorizationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthorizationRequest): AuthorizationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string client_id */ 1:
                    message.clientId = reader.string();
                    break;
                case /* string redirect_uri */ 2:
                    message.redirectUri = reader.string();
                    break;
                case /* string response_type */ 3:
                    message.responseType = reader.string();
                    break;
                case /* string scope */ 4:
                    message.scope = reader.string();
                    break;
                case /* string state */ 5:
                    message.state = reader.string();
                    break;
                case /* string code_challenge */ 6:
                    message.codeChallenge = reader.string();
                    break;
                case /* string code_challenge_method */ 7:
                    message.codeChallengeMethod = reader.string();
                    break;
                case /* string nonce */ 8:
                    message.nonce = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthorizationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string client_id = 1; */
        if (message.clientId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientId);
        /* string redirect_uri = 2; */
        if (message.redirectUri !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.redirectUri);
        /* string response_type = 3; */
        if (message.responseType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.responseType);
        /* string scope = 4; */
        if (message.scope !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.scope);
        /* string state = 5; */
        if (message.state !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.state);
        /* string code_challenge = 6; */
        if (message.codeChallenge !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.codeChallenge);
        /* string code_challenge_method = 7; */
        if (message.codeChallengeMethod !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.codeChallengeMethod);
        /* string nonce = 8; */
        if (message.nonce !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.nonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.AuthorizationRequest
 */
export const AuthorizationRequest = new AuthorizationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizationResponse$Type extends MessageType<AuthorizationResponse> {
    constructor() {
        super("auth.AuthorizationResponse", [
            { no: 1, name: "redirect_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuthorizationResponse>): AuthorizationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.redirectUri = "";
        message.code = "";
        message.state = "";
        if (value !== undefined)
            reflectionMergePartial<AuthorizationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthorizationResponse): AuthorizationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string redirect_uri */ 1:
                    message.redirectUri = reader.string();
                    break;
                case /* string code */ 2:
                    message.code = reader.string();
                    break;
                case /* string state */ 3:
                    message.state = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthorizationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string redirect_uri = 1; */
        if (message.redirectUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.redirectUri);
        /* string code = 2; */
        if (message.code !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.code);
        /* string state = 3; */
        if (message.state !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.AuthorizationResponse
 */
export const AuthorizationResponse = new AuthorizationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenRequest$Type extends MessageType<TokenRequest> {
    constructor() {
        super("auth.TokenRequest", [
            { no: 1, name: "grant_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "redirect_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "code_verifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "client_secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenRequest>): TokenRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.grantType = "";
        message.code = "";
        message.redirectUri = "";
        message.codeVerifier = "";
        message.clientId = "";
        message.clientSecret = "";
        if (value !== undefined)
            reflectionMergePartial<TokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenRequest): TokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string grant_type */ 1:
                    message.grantType = reader.string();
                    break;
                case /* string code */ 2:
                    message.code = reader.string();
                    break;
                case /* string redirect_uri */ 3:
                    message.redirectUri = reader.string();
                    break;
                case /* string code_verifier */ 4:
                    message.codeVerifier = reader.string();
                    break;
                case /* string client_id */ 5:
                    message.clientId = reader.string();
                    break;
                case /* string client_secret */ 6:
                    message.clientSecret = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string grant_type = 1; */
        if (message.grantType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.grantType);
        /* string code = 2; */
        if (message.code !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.code);
        /* string redirect_uri = 3; */
        if (message.redirectUri !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.redirectUri);
        /* string code_verifier = 4; */
        if (message.codeVerifier !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.codeVerifier);
        /* string client_id = 5; */
        if (message.clientId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.clientId);
        /* string client_secret = 6; */
        if (message.clientSecret !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.clientSecret);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.TokenRequest
 */
export const TokenRequest = new TokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenResponse$Type extends MessageType<TokenResponse> {
    constructor() {
        super("auth.TokenResponse", [
            { no: 1, name: "access_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "expires_in", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "id_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenResponse>): TokenResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessToken = "";
        message.tokenType = "";
        message.expiresIn = 0n;
        message.idToken = "";
        message.refreshToken = "";
        if (value !== undefined)
            reflectionMergePartial<TokenResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenResponse): TokenResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string access_token */ 1:
                    message.accessToken = reader.string();
                    break;
                case /* string token_type */ 2:
                    message.tokenType = reader.string();
                    break;
                case /* int64 expires_in */ 3:
                    message.expiresIn = reader.int64().toBigInt();
                    break;
                case /* string id_token */ 4:
                    message.idToken = reader.string();
                    break;
                case /* string refresh_token */ 5:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string access_token = 1; */
        if (message.accessToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessToken);
        /* string token_type = 2; */
        if (message.tokenType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tokenType);
        /* int64 expires_in = 3; */
        if (message.expiresIn !== 0n)
            writer.tag(3, WireType.Varint).int64(message.expiresIn);
        /* string id_token = 4; */
        if (message.idToken !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.idToken);
        /* string refresh_token = 5; */
        if (message.refreshToken !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.TokenResponse
 */
export const TokenResponse = new TokenResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserInfoResponse$Type extends MessageType<UserInfoResponse> {
    constructor() {
        super("auth.UserInfoResponse", [
            { no: 1, name: "sub", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "email_verified", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UserInfoResponse>): UserInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sub = "";
        message.name = "";
        message.email = "";
        message.emailVerified = false;
        if (value !== undefined)
            reflectionMergePartial<UserInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserInfoResponse): UserInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sub */ 1:
                    message.sub = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string email */ 3:
                    message.email = reader.string();
                    break;
                case /* bool email_verified */ 4:
                    message.emailVerified = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sub = 1; */
        if (message.sub !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sub);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string email = 3; */
        if (message.email !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        /* bool email_verified = 4; */
        if (message.emailVerified !== false)
            writer.tag(4, WireType.Varint).bool(message.emailVerified);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.UserInfoResponse
 */
export const UserInfoResponse = new UserInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JWKSResponse$Type extends MessageType<JWKSResponse> {
    constructor() {
        super("auth.JWKSResponse", [
            { no: 1, name: "keys", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => JWKSResponse_JWK }
        ]);
    }
    create(value?: PartialMessage<JWKSResponse>): JWKSResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        if (value !== undefined)
            reflectionMergePartial<JWKSResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JWKSResponse): JWKSResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.JWKSResponse.JWK keys */ 1:
                    message.keys.push(JWKSResponse_JWK.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JWKSResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.JWKSResponse.JWK keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            JWKSResponse_JWK.internalBinaryWrite(message.keys[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.JWKSResponse
 */
export const JWKSResponse = new JWKSResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JWKSResponse_JWK$Type extends MessageType<JWKSResponse_JWK> {
    constructor() {
        super("auth.JWKSResponse.JWK", [
            { no: 1, name: "kty", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "use", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "alg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "n", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "e", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<JWKSResponse_JWK>): JWKSResponse_JWK {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kty = "";
        message.kid = "";
        message.use = "";
        message.alg = "";
        message.n = "";
        message.e = "";
        if (value !== undefined)
            reflectionMergePartial<JWKSResponse_JWK>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JWKSResponse_JWK): JWKSResponse_JWK {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string kty */ 1:
                    message.kty = reader.string();
                    break;
                case /* string kid */ 2:
                    message.kid = reader.string();
                    break;
                case /* string use */ 3:
                    message.use = reader.string();
                    break;
                case /* string alg */ 4:
                    message.alg = reader.string();
                    break;
                case /* string n */ 5:
                    message.n = reader.string();
                    break;
                case /* string e */ 6:
                    message.e = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JWKSResponse_JWK, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string kty = 1; */
        if (message.kty !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kty);
        /* string kid = 2; */
        if (message.kid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kid);
        /* string use = 3; */
        if (message.use !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.use);
        /* string alg = 4; */
        if (message.alg !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.alg);
        /* string n = 5; */
        if (message.n !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.n);
        /* string e = 6; */
        if (message.e !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.e);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.JWKSResponse.JWK
 */
export const JWKSResponse_JWK = new JWKSResponse_JWK$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterRequest$Type extends MessageType<RegisterRequest> {
    constructor() {
        super("auth.RegisterRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterRequest>): RegisterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<RegisterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterRequest): RegisterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.RegisterRequest
 */
export const RegisterRequest = new RegisterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterResponse$Type extends MessageType<RegisterResponse> {
    constructor() {
        super("auth.RegisterResponse", [
            { no: 1, name: "user_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterResponse>): RegisterResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = 0n;
        if (value !== undefined)
            reflectionMergePartial<RegisterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterResponse): RegisterResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 user_id */ 1:
                    message.userId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 user_id = 1; */
        if (message.userId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.RegisterResponse
 */
export const RegisterResponse = new RegisterResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRequest$Type extends MessageType<LoginRequest> {
    constructor() {
        super("auth.LoginRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "app_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LoginRequest>): LoginRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = "";
        message.appId = 0;
        if (value !== undefined)
            reflectionMergePartial<LoginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRequest): LoginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                case /* int32 app_id */ 3:
                    message.appId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        /* int32 app_id = 3; */
        if (message.appId !== 0)
            writer.tag(3, WireType.Varint).int32(message.appId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.LoginRequest
 */
export const LoginRequest = new LoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginResponse$Type extends MessageType<LoginResponse> {
    constructor() {
        super("auth.LoginResponse", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginResponse>): LoginResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<LoginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginResponse): LoginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.LoginResponse
 */
export const LoginResponse = new LoginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IsAdminRequest$Type extends MessageType<IsAdminRequest> {
    constructor() {
        super("auth.IsAdminRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<IsAdminRequest>): IsAdminRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = 0n;
        if (value !== undefined)
            reflectionMergePartial<IsAdminRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IsAdminRequest): IsAdminRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 user_id */ 1:
                    message.userId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IsAdminRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 user_id = 1; */
        if (message.userId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.IsAdminRequest
 */
export const IsAdminRequest = new IsAdminRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IsAdminResponse$Type extends MessageType<IsAdminResponse> {
    constructor() {
        super("auth.IsAdminResponse", [
            { no: 1, name: "is_admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<IsAdminResponse>): IsAdminResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isAdmin = false;
        if (value !== undefined)
            reflectionMergePartial<IsAdminResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IsAdminResponse): IsAdminResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_admin */ 1:
                    message.isAdmin = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IsAdminResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_admin = 1; */
        if (message.isAdmin !== false)
            writer.tag(1, WireType.Varint).bool(message.isAdmin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.IsAdminResponse
 */
export const IsAdminResponse = new IsAdminResponse$Type();
/**
 * @generated ServiceType for protobuf service auth.Auth
 */
export const Auth = new ServiceType("auth.Auth", [
    { name: "Discover", options: { "google.api.http": { get: "/.well-known/openid-configuration" } }, I: Empty, O: DiscoveryResponse },
    { name: "Authorize", options: { "google.api.http": { get: "/authorize" } }, I: AuthorizationRequest, O: AuthorizationResponse },
    { name: "Token", options: { "google.api.http": { post: "/token", body: "*" } }, I: TokenRequest, O: TokenResponse },
    { name: "UserInfo", options: { "google.api.http": { get: "/userinfo" } }, I: Empty, O: UserInfoResponse },
    { name: "JWKS", options: { "google.api.http": { get: "/jwks" } }, I: Empty, O: JWKSResponse },
    { name: "Register", options: {}, I: RegisterRequest, O: RegisterResponse },
    { name: "Login", options: {}, I: LoginRequest, O: LoginResponse },
    { name: "IsAdmin", options: {}, I: IsAdminRequest, O: IsAdminResponse }
]);
